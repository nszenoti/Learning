# 0_roadmap

Excellent approach! Pattern-based learning is the most efficient way to master DSA. Let's reverse-engineer AlgoMonster's Core Patterns structure and create a **free, pattern-focused roadmap** that we'll tackle systematically.

Here's your **Core Patterns Roadmap** (AlgoMonster-Style):

---

## **Phase 1: Basic Data Structures (Foundation)**
*Master the building blocks - not just syntax, but their problem-solving characteristics*

1. **Arrays & Strings** (1 week)
2. **Linked Lists** (3 days)
3. **Stacks & Queues** (3 days)
4. **Hash Tables** (4 days)
5. **Trees: Binary & BST** (1 week)
6. **Heaps / Priority Queues** (3 days)
7. **Graph Representation** (Adjacency List/Map) (2 days)

---

## **Phase 2: Algorithm Patterns (The Core)**
*These are your 80/20 patterns - master these and 80% of medium/hard problems become accessible*

### **Pointer Techniques**
8. **Two Pointers** (3 days)
   - Opposite ends (Array)
   - Fast-Slow (LinkedList)
   - Sliding Window Variant

9. **Sliding Window** (Fixed & Dynamic) (4 days)

### **Traversal & Search Patterns**
10. **Binary Search** (4 days)
    - Standard
    - Lower/Upper Bound
    - Search in rotated array
    - Search on answer space

11. **Tree BFS (Level-order)** (3 days)
12. **Tree DFS (Pre/In/Post-order)** (3 days)
13. **Graph BFS/DFS** (4 days)
    - Connected Components
    - Multi-source BFS

### **Advanced Array Patterns**
14. **Merge Intervals** (3 days)
15. **Cyclic Sort** (2 days)
16. **In-place LinkedList Reversal** (2 days)

### **Backtracking Patterns**
17. **Subsets** (3 days)
18. **Permutations** (3 days)
19. **Combination Sum** (3 days)

### **Dynamic Programming Patterns**
20. **0/1 Knapsack** (4 days)
21. **Unbounded Knapsack** (3 days)
22. **Fibonacci Sequence (DP)** (3 days)
23. **Longest Common Subsequence** (4 days)
24. **Longest Increasing Subsequence** (3 days)
25. **Matrix Chain Multiplication** (3 days)
26. **DP on Strings** (Edit Distance) (3 days)

### **Graph Algorithms**
27. **Topological Sort (Kahn's & DFS)** (3 days)
28. **Union-Find (Disjoint Set)** (4 days)
29. **Dijkstra's Algorithm** (3 days)

### **Greedy & Other**
30. **Monotonic Stack** (3 days)
31. **Monotonic Queue** (2 days)

---

## **Phase 3: Simulation & Advanced Techniques**
*Specialized tools for specific problem types*

32. **Bit Manipulation** (4 days)
33. **Trie Operations** (3 days)
34. **Segment Tree / Fenwick Tree** (4 days)
35. **Pattern Matching (KMP, Rabin-Karp)** (3 days)

---

## **How We'll Execute This:**

For **each pattern**, we'll cover:
1. **Intuition & When to use it** (recognition cues)
2. **Core Template/Blueprint** (Python skeleton)
3. **Key Variations** (how it morphs)
4. **5-8 Handpicked LeetCode problems** (progressive difficulty)
5. **Common Pitfalls & Optimization tricks**

---

Yes, this roadmap is solid and covers ~90% of AlgoMonster's Core Patterns. For a complete "only guide" revision notes, **add these critical patterns**:

**Missing Core Patterns to Add:**

1. **Greedy Algorithms** (major category)
   - Interval Scheduling (Activity Selection)
   - Huffman Encoding
   - General Greedy strategy

2. **DP Sub-patterns**
   - DP on Grids (min/max path, unique paths)
   - DP with Bitmasking (advanced)

3. **Tree Patterns**
   - LCA (Lowest Common Ancestor)
   - Tree DP (diameter, max path sum)

4. **Graph Patterns**
   - Cycle Detection (both graph & LL)
   - BFS on Grid (shortest path in matrices)
   - Bipartite Graph Check

5. **Advanced DS/Techniques**
   - Two Heaps (median finder, sliding window median)
   - Reservoir Sampling
   - Fast Power/Modular Exponentiation

6. **LinkedList**
   - Floyd's Cycle Detection (explicit pattern)

**Optional but good for completeness:**
- MST (Kruskal/Prim)
- Bellman-Ford
- Sieve of Eratosthenes

**â€” Ready to start?** Pick Pattern #1 (Arrays) or tell me your weakest area to attack first.