2_dual_nature_objects.md

You're right to be frustrated. Let me cut the abstraction and give you the exact mechanism:

## The Brutal Truth: Dual-Nature Objects

When you call `callback.toJS`, you get a **Dart object** whose internal layout contains a **raw pointer to a generated JavaScript function stub**. This is not a normal Dart object—it's a hybrid that the compiler treats specially.

### What Actually Happens at the Boundary

```dart
void dartCallback() => print('hello');
var wrapper = dartCallback.toJS; // Returns a Dart object of type JSExportedDartFunction
web.window['fn'] = wrapper; 
```

**The assignment line is where the magic occurs.** The Dart runtime doesn't dump the Dart object into JS memory (which would be nonsense). Instead:

1. It extracts the **JS function stub pointer** from the wrapper's internal fields
2. It writes **that pointer** to `window.fn` in the JavaScript heap
3. The JS side sees a **genuine, callable JavaScript function** (not a Dart object)

The generated JS stub looks conceptually like this:

```javascript
function() {
  dartRuntime.invoke(0x12345678, arguments); // 0x12345678 = callback's Dart identity
}
```

### Memory: The Dangling Pointer Problem

If you don't store `wrapper` in Dart:

```dart
void BrokenExample() {
  web.window['fn'] = (() => print('test')).toJS; 
  // Dart GC sees wrapper is unreferenced → collects it
  // The Dart identity (0x12345678) in the JS stub is now INVALID
  // JS later calls window.fn() → CRASH (accessing freed memory)
}
```

**The JS stub exists but becomes a dangling pointer to a dead Dart object.**

### Storage: What Must You Keep?

You must keep **any reference that prevents Dart GC from collecting the callback**:

```dart
// ✅ Option A: Keep original callback
final _callbacks = <Function>[];
void func() {
  final cb = () => print('ok');
  web.window['fn'] = cb.toJS;
  _callbacks.add(cb); // Keeps both cb and its JS wrapper alive
}

// ✅ Option B: Keep the wrapper itself
final _wrappers = <JSFunction>[];
void func() {
  final wrapper = callback.toJS;
  web.window['fn'] = wrapper;
  _wrappers.add(wrapper); // Keeps wrapper alive
}
```

Both work because the `JSFunction` wrapper holds a strong reference to the original Dart callback internally.

### Type Identity: Clarified

- **`JSAny`**: A Dart interface. Empty marker. Worthless for understanding memory.
-  **`JSExportedDartFunction`**  : **Concrete Dart class** with native fields. Lives in Dart heap.
- **What JS sees**: A **separate JS function object** in JS heap, generated by compiler, containing a pointer to the Dart side.

**They are two distinct objects (Dart wrapper + JS stub) linked by a pointer pair.**

### Holistic Summary

1. `toJS` creates a **Dart-level handle** to a compiler-generated **JS-level stub**
2. The handle is a **Dart GC-managed object** with a native pointer field
3. When crossing to JS, the **stub pointer** is written, not the Dart object
4. **JS calls the stub → stub marshals → Dart callback executes**
5. **You MUST store the Dart handle** to keep the callback identity alive for the stub

The moment Dart collects the handle, the JS stub points at garbage. That's your crash.